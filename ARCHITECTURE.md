This part of the document and will only be updated by a human document maintainer.

### Listified
This document details the architecture, application design, pattersn, database schema, and overall structure of the app in a way that contains everything that is necessary to build it. This app should be updated as the app it built and care should be taken to ensure that it accurately reflects the current state, what has been done, and what remains to be done.

The app that is going to be built is named Listifed, and it is going to be an app that does one thing and does it really well, and that is allow users to create lists, cross off items on those lists, and get those lists done.

### Software Stack
This application will utilize the following software components.
- The repo is hosted in git, written in python, and utilizes uv package manager
- The app is FastAPI based backend
- The the backend database is postgres
- The app will be running on uvicorn
- SQLAlchemy will be used with ORM style queries for all DB interactions
- Alembic will be used to handle database migrations
- The app will utilize unit tests written in pytest, and integration tests
- The repo structure will use go task to run the app, run the tests, perform linting, check formatting
- The ruff application will be used for linting and formatting
- The application will ultimately be containerized, with the ultimate goal of running in docker compose
- Will use astral ty for type checking
- Any technologies used for the front end are To Be Determined - create suggestions in the section below. This piece will be implemented after the API is complete, so it does not need to be decided upon at this time.
- Pydantic models will be used for all API requests and responses


### Database Design
#### Tables
The follow section lists table and then under each table name is a column name and type
##### Table Name: list
- id - UUIDv4
- name - varchar
- description - varchar
- created_at - timestamptz
- updated_at - timestamptz
- completed_at - timestamptz
- deleted_at - timestamptz

##### Table Name: items
- id - UUIDv4
- list_id - foreign key to list.id
- name - varchar
- description - varchar
- order - integer
- created_at - timestamptz
- updated_at - timestamptz
- completed_at - timestamptz
- deleted_at - timestamptz
 

### Application Design
#### Style Notes
- Must include thorough docstrings in all PEP advised places
- Must pass all linting and formatting rules
- All changes to the DB must occur through alembic migration
- Alembic migrations can be autogenerated by SQLAlchemy, but should be carefully reviewed and edited to ensure they are correct
- After making any set of changes to the code always run the linter, the formatter, and the type checker and then fix any errors that are reported

#### Application Notes
- The application will be single user focused, designed for a single household sharing all lists - due to these we can keep these parts of the app simplified
- This is a single household per deployment model - no user/authentication abstraction needed
- The app supports the ability to add lists, rename lists, delete lists
- Within each list the user may add items, delete items, rename items, and reorder items
- Completion timestamps are tracked independently - completing a list does not automatically complete its items
- When deleting we should always soft delete by marking `deleted_at`
- The API should have full CRUD capability on both tables, and all interactions with DB should be through API
- The application should look good on both desktop and mobile
- Initially the UI will be minimalist, with the intent of adding some customization later
- Full tests should be generated for all API endpoints
- Testing should be done through ephemeral DB that fully replicates the production DB
- Error handling does not need to be extensive, but we should generally follow all HTTP status code best practices

#### Endpoint Notes
There must be full CRUD capability on underlying tables The endpoints should take the following shape.

- GET | POST /lists
- GET | PUT | PATCH | DELETE /lists/{list_id}
- GET | POST /lists/{list_id}/items
- GET | PUT | PATCH | DELETE /lists/{list_id}/items/{item_id}

Other endpoint notes:
- No authentication is required for the API at this time
- All endpoints should be well documented with detailed descriptions of the request and response payloads
- No pagination is required for the API at this time

### UI Design
The section will contain the design of the UI, and the implementation of the UI. It will be updated by hand, and referred to by numbers to indicate which actions are being referred to.

#### UI Requirements
1. The UI will allow users to create lists, rename lists, delete lists
2. The UI will allow users to add items to lists, rename items, delete items, and reorder items
3. The UI will allow users to mark items as complete
4. The UI will allow users to mark lists as complete
5. The UI will allow users to delete lists and items
6. The UI will allow users to reorder lists and items
7. The UI will allow users to toggle dark mode
8. The UI will allow users to toggle light mode

#### UI Layout
- The left hand side will have a vertical sidebar that contains all the lists
- The sidebar will have a button to create a new list
- The sidebar will have a button to toggle dark mode
- The sidebar will have a button to toggle light mode
- The sidebar will have a button to toggle the sidebar
- The sidebar will have a button to toggle the sidebar
- The main panel will display the select list
- Clicking and dragging on an item on the list will allow the user to reorder the item
- Clicking on the list name will allow the user to edit the list name
- Clicking on the list description will allow the user to edit the list description
- Clicking on the list item will allow the user to edit the item name and description


---

Everything below this line is to be maintained by an LLM agent. It should be updated to contain current status, to do items, future work to be done. It should be updated as appropriate to ensure all context is maintained and that the application work could be continued at any time by any agent.

## Agent-Maintained Section

### Current Status
- Architecture document has been reviewed and clarified with design decisions
- Design clarifications added regarding single household deployment, independent completion tracking, and item reordering
- **STEP 1 COMPLETE**: Project structure, dependencies, and top-level repo items initialized
- **STEP 2 COMPLETE**: SQLAlchemy DB models and Alembic migration created and tested
- **STEP 3 COMPLETE**: FastAPI endpoints with full CRUD functionality implemented
- **STEP 4 COMPLETE**: Comprehensive unit tests for all endpoints with 59% code coverage
- **TYPE SAFETY COMPLETE**: Migrated to astral `ty` type checker and implemented proper SQLAlchemy Mapped annotations

### Completed Tasks
- ✅ **Step 1**: Project initialization complete
  - Created complete project structure (src/, tests/, migrations/ directories)
  - Initialized pyproject.toml with all required dependencies (FastAPI, SQLAlchemy, Alembic, pytest, ruff, astral ty, etc.)
  - Created Taskfile.yml with task automation for development workflows (dev, test, lint, format, type-check, migrate, check, clean)
  - Created comprehensive README.md with project overview, setup instructions, and API documentation
  - Created .gitignore for Python/uv projects
  - Created .env.example with environment variables template
  - Initialized Alembic configuration (alembic.ini, env.py, script.py.mako)
  - Created basic FastAPI main.py with health check and root endpoints
  - All dependencies installed and uv.lock generated

- ✅ **Step 2**: SQLAlchemy DB models and Alembic migration complete
  - Created database.py with List and Item SQLAlchemy ORM models
  - Configured async database support using asyncpg driver
  - Created settings.py with Pydantic BaseSettings for configuration management
  - Updated .env file with PostgreSQL connection details (POSTGRES_DSN)
  - Modified migrations/env.py to support async operations with asyncpg
  - Created manual Alembic migration file (740963925b9d_create_list_and_items_tables.py)
  - Migration includes proper upgrade() and downgrade() functions
  - Verified migration execution - tables successfully created in PostgreSQL

- ✅ **Step 3**: FastAPI endpoints with full CRUD functionality complete
  - Created schemas.py with Pydantic models for all request/response payloads:
    - ListBase, ListCreate, ListUpdate, ListResponse
    - ItemBase, ItemCreate, ItemUpdate, ItemResponse
  - Created routers/lists.py with endpoints:
    - GET /lists - List all non-deleted lists
    - POST /lists - Create a new list
    - GET /lists/{list_id} - Get specific list
    - PUT /lists/{list_id} - Update list
    - PATCH /lists/{list_id} - Partially update list
    - DELETE /lists/{list_id} - Soft delete list
  - Created routers/items.py with endpoints:
    - GET /lists/{list_id}/items - List all items in a list
    - POST /lists/{list_id}/items - Create item in list
    - GET /lists/{list_id}/items/{item_id} - Get specific item
    - PUT /lists/{list_id}/items/{item_id} - Update item
    - PATCH /lists/{list_id}/items/{item_id} - Partially update item
    - DELETE /lists/{list_id}/items/{item_id} - Soft delete item
  - All endpoints implement proper HTTP status codes (201 for creation, 204 for delete, 404 for not found)
  - All endpoints use soft deletion (mark deleted_at timestamp)
  - All endpoints include comprehensive docstrings and type hints
  - Items automatically ordered by order column in list retrieval
  - Parent list validation for all item operations

- ✅ **Step 4**: Comprehensive unit tests for all endpoints complete
  - Created tests/conftest.py with shared test fixtures:
    - test_db fixture: In-memory SQLite database with proper async setup/teardown
    - client fixture: Async HTTP client with test database injection via dependency override
  - Created tests/test_lists.py with 19 test cases covering:
    - GET /lists: empty lists, multiple lists, deleted list filtering
    - POST /lists: minimal creation, with description, validation failures
    - GET /lists/{list_id}: successful retrieval, 404 errors, deleted list filtering
    - PUT /lists/{list_id}: name/description updates, completion marking, 404 errors
    - PATCH /lists/{list_id}: partial updates, empty payload handling
    - DELETE /lists/{list_id}: soft deletion, 404 errors, cascading effects
  - Created tests/test_items.py with 24 test cases covering:
    - GET /lists/{list_id}/items: empty lists, ordering, deleted filtering, parent validation
    - POST /lists/{list_id}/items: minimal creation, description, validation, parent validation
    - GET /lists/{list_id}/items/{item_id}: successful retrieval, 404s, wrong list validation
    - PUT /lists/{list_id}/items/{item_id}: updates, completion marking, parent validation
    - PATCH /lists/{list_id}/items/{item_id}: partial updates, empty payloads
    - DELETE /lists/{list_id}/items/{item_id}: soft deletion, 404s, cascading effects
  - All 43 tests passing with 0 failures
  - 59% overall code coverage (100% coverage for schemas, settings, and routers/__init__)
  - Tests use in-memory SQLite for fast execution (~1.7 seconds total)
  - Pydantic models updated to use ConfigDict instead of deprecated Config classes

- ✅ **Type Safety Enhancement**: Full type safety without type: ignore overrides
  - Migrated type checker from pyright to astral `ty` for improved performance
  - Updated all ORM models to use SQLAlchemy's modern `Mapped[T]` annotation pattern
  - All fields in List and Item models now have explicit type hints via `Mapped[type] = mapped_column(...)`
  - Updated all router endpoints to explicitly convert ORM instances to Pydantic response models using `model_validate()`
  - Removed all `# type: ignore[return-value]` comments - pure type safety achieved
  - Updated Taskfile.yml to use new `ty check src` command
  - All 43 tests continue to pass with improved type safety
  - Type checking passes cleanly with zero diagnostics

### Design Decisions Documented
- Single household per deployment model (no multi-user abstraction)
- Item reordering via `order` column in items table
- Independent completion timestamps for lists and items
- Frontend technology stack to be determined after API completion
- Type safety priority: Use modern SQLAlchemy Mapped annotations and explicit Pydantic conversions over type ignores

### Next Steps
1. ~~Create project structure, define dependencies, compose general top-level repo items, go task, README, dir structure~~ ✅ DONE
2. ~~Setup sqlalchemy DB models and alembic migration~~ ✅ DONE
3. ~~Create FastAPI endpoints with full CRUD functionality on underlying tables, including carefully typed pydantic models for all requests and responses~~ ✅ DONE
4. ~~Create unit tests for all endpoints~~ ✅ DONE

### API Specification Complete
All 4 core development steps have been completed. The Listified API is now fully functional with:
- 12 RESTful endpoints (6 for lists, 6 for items)
- Complete CRUD operations on both resource types
- Comprehensive test coverage (43 test cases)
- Type-safe request/response models with Pydantic
- Async/await throughout the entire stack
- Soft deletion support for data preservation
- Proper HTTP status codes and error handling

### Frontend Technology Decision

After evaluating multiple frontend approaches (React, Vue, Svelte, HTMX, Alpine.js, vanilla JS), the following decision was made:

**Selected Stack: Alpine.js + PicoCSS + Sortable.js**

**Technology Choices:**
- **Alpine.js (15KB gzipped)**: Minimal reactive JavaScript library for data binding and component state
- **PicoCSS (9KB gzipped)**: Semantic HTML-first CSS framework with built-in mobile responsiveness
- **Sortable.js (2KB gzipped)**: Lightweight drag-and-drop library for item reordering
- **Total bundle size**: ~26KB (smaller than a single high-resolution image)

**Why this approach:**

1. **Aligns with project philosophy**: Minimal dependencies (3), no build process, close to bare HTML/CSS
2. **Client-side SPA**: Leverages existing REST API without requiring backend changes
3. **Drag-and-drop ready**: Sortable.js enables smooth item reordering essential for list management
4. **Mobile-first**: PicoCSS provides excellent responsive design without utility classes or configuration
5. **Developer experience**: Alpine.js uses Vue-like syntax for reactive data binding - clean and intuitive
6. **Zero build process**: CDN delivery, no webpack/vite/npm complexity
7. **Scalable simplicity**: Code can grow without architectural bloat (Alpine handles 100+ components gracefully)

**Why NOT other approaches:**

- **React/Vue/Svelte**: 3-5x larger bundle size, require build tools, npm ecosystem overhead - overkill for single-household CRUD app
- **HTMX + Jinja2**: Would require significant backend restructuring to add HTML-returning routes alongside existing API
- **Pure Vanilla JS**: Excessive boilerplate for DOM manipulation, event handling, and state management
- **Server-side rendering**: Increases server complexity and doesn't align with existing REST API architecture

**Implementation approach:**

1. Single `index.html` entry point with inline Alpine.js components
2. Minimal custom CSS for app-specific styling (dark mode toggle, animations)
3. API service layer abstracting fetch calls to existing REST endpoints
4. Responsive grid layout for mobile, tablet, and desktop
5. Optimistic UI updates for better perceived performance
6. Loading states and error handling for network operations

**File structure:**
```
static/
├── css/
│   └── custom.css       # App-specific styles
├── js/
│   └── app.js          # Alpine.js components and API layer
└── index.html          # Single-page application
```

**Key features to implement:**

- Lists CRUD (create, read, update, delete)
- Items CRUD within lists
- Drag-and-drop item reordering (Sortable.js integration)
- Completion tracking for lists and items
- Responsive design for mobile and desktop
- Loading states and error notifications

**Estimated effort**: ~1 day focused development
- Lists view: 2 hours
- Items view with drag-and-drop: 3 hours
- Styling and mobile polish: 2 hours
- Error handling and refinement: 1 hour

### Frontend Implementation Progress

#### Step 1: Project Structure and Base Implementation ✅ COMPLETE (Initial)

**Initial Implementation Completed:**
- Created `static/` directory structure with `css/` and `js/` subdirectories
- Implemented `static/index.html` (211 lines):
  - Alpine.js component setup with full application state management
  - Lists view with CRUD operations and completion tracking
  - List detail view with items management
  - Drag-and-drop container for Sortable.js integration
  - Dark mode toggle with localStorage persistence
  - Error notification and loading state UI
  - Responsive layout with semantic HTML
- Implemented `static/css/custom.css` (257 lines):
  - Grid layout for lists cards (responsive 300px+ columns)
  - Item row styling with grab cursor for drag-and-drop
  - Mobile-optimized touch targets and responsive breakpoints
  - Dark mode support via CSS variables
  - Smooth animations and transitions
  - Badge styling for completion indicators
  - Form group responsive layout
- Implemented `static/js/app.js` (323 lines):
  - Complete Alpine.js state management with all CRUD operations
  - API service layer with error handling and loading states
  - Lists operations: create, read, update (completion), delete
  - Items operations: create, read, update (completion), delete
  - Drag-and-drop integration with Sortable.js for item reordering
  - Item order update on drop with batch API calls
  - Dark mode toggle with persistence
  - Date formatting utility
  - Optimistic UI updates for better UX
- Updated `src/listified/main.py`:
  - Added static file mounting at `/static`
  - Proper path resolution for static directory
  - Integration with existing CORS middleware
- **Test Results**: All 43 existing API tests pass
- **Code Quality**: Linting and type checking pass, 60% coverage maintained
- **Bundle Size**: ~26KB total (Alpine.js 15KB + PicoCSS 9KB + Sortable.js 2KB)

#### Step 2: UI Redesign to Match Requirements ✅ COMPLETE

**UI Requirements Implemented:**
1. ✅ Allow users to create lists, rename lists, delete lists
2. ✅ Allow users to add items to lists, rename items, delete items, and reorder items
3. ✅ Allow users to mark items as complete
4. ✅ Allow users to mark lists as complete
5. ✅ Allow users to delete lists and items
6. ✅ Allow users to reorder lists and items (via drag-and-drop)
7. ✅ Allow users to toggle dark mode
8. ✅ Allow users to toggle light mode

**UI Layout Implemented:**
- ✅ Left vertical sidebar with all lists (collapsible to icon-only mode)
- ✅ Sidebar header with app name and collapse toggle button
- ✅ Create new list form at top of sidebar
- ✅ List items in sidebar with drag-and-drop reordering
- ✅ Active list highlighting (teal background)
- ✅ Completion badges on lists
- ✅ Quick actions on hover (complete, delete)
- ✅ Dark/Light mode toggle button in sidebar footer
- ✅ Main panel displays selected list with full details
- ✅ Click-to-edit inline editing for list names and descriptions
- ✅ Click-to-edit inline editing for item names and descriptions
- ✅ Drag-and-drop item reordering with order persistence
- ✅ Responsive mobile layout (sidebar converts to horizontal top bar)

**Changes from Initial Implementation:**
- Replaced single-view layout with sidebar + main panel two-column design (CSS Grid)
- Added collapsible sidebar with localStorage persistence
- Implemented inline editing for all text fields (click to edit, ESC to cancel, Enter to save)
- Added dedicated item actions buttons (complete/delete)
- Enhanced styling with editable indicators (hover effects, cursor changes)
- Reorganized HTML structure for semantic sidebar navigation
- Added list reordering via Sortable.js in sidebar
- Improved mobile responsiveness with horizontal sidebar layout
- Updated CSS from 257 lines to 599 lines (comprehensive layout system)
- Updated JavaScript from 318 lines to 520 lines (inline editing, sidebar management)

**File Updates:**
- `static/index.html`: Restructured from 211 to 313 lines
  - Two-column layout with sidebar and main panel
  - Inline editing inputs for list/item names and descriptions
  - Sidebar navigation with list menu
  - Dark/light mode toggle in sidebar footer
- `static/css/custom.css`: Expanded from 257 to 599 lines
  - CSS Grid layout for app container
  - Sidebar styling with collapse animation
  - Main panel flex layout
  - Inline editing styles with visual feedback
  - Mobile-first responsive design
  - Dark mode CSS variable overrides
- `static/js/app.js`: Enhanced from 318 to 520 lines
  - Inline editing state management (editingListName, editingListDesc, editingItemId)
  - Sidebar collapse state with localStorage persistence
  - List reordering via Sortable.js in sidebar
  - List name/description inline editing (start, cancel, save)
  - Item name/description inline editing (start, cancel, save)
  - Keyboard support (Enter to save, Escape to cancel)
  - Original value tracking for rollback on errors

**Test Results:**
- ✅ All 43 API tests passing
- ✅ JavaScript syntax validated
- ✅ CSS compiles without errors
- ✅ HTML structure validated
- ✅ Ruff linting passes
- ✅ Type checking passes
- ✅ 60% code coverage maintained

**Bundle Size:** Still ~26KB (no additional dependencies added)

**Notes on Implementation:**
- Initialization uses Alpine.js `x-init` directive for proper component setup
- Sortable.js is re-initialized after items load with 100ms timeout for proper DOM synchronization
- Optimistic UI updates provide immediate feedback while server processes requests
- Dark mode preference persisted in localStorage across browser sessions
- All fetch calls include proper error handling and user feedback
- Form validation on client side to reduce unnecessary API calls
- CSS Grid and Flexbox used for responsive layout without utility classes
- List selection and sidebar state management in Alpine store
- JavaScript syntax validated with Node.js parser
- All 43 existing API tests continue to pass
- Code quality maintained with ruff and ty type checking
- Sidebar responsive design: vertical on desktop, horizontal on mobile (<768px)
- Form resets automatically after successful creation
- Error messages display in banner at top of UI
- Loading states prevent duplicate submissions while requests pending

### Next Steps
- Testing the application with a running server and database
- Manual testing of:
  - Sidebar list selection and highlighting
  - Sidebar collapse/expand functionality and persistence
  - Inline editing for list names and descriptions
  - Inline editing for item names and descriptions
  - Drag-and-drop list reordering in sidebar
  - Drag-and-drop item reordering in main panel
  - Dark/light mode toggle persistence
  - Mobile responsive layout and horizontal sidebar
  - Error handling and recovery
  - Create list and item form resets
- Performance optimization if needed
- Accessibility audit (ARIA labels already implemented)

### Future Work
- User interface refinement and polish
- Optional: Dark mode toggle and theme customization (already implemented in code)
- Optional: Additional customization features beyond minimal UI
- Optional: Progressive Web App (PWA) features for mobile installation